{
  "language": "Solidity",
  "sources": {
    "contracts/YourContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title University Election Contract\n * @dev A secure contract for managing university elections and professor enrollments\n * @notice This contract handles university elections with encrypted voting and professor management\n */\ncontract YourContract {\n    // ============ CONSTANTS ============\n    \n    uint256 public constant CAP = 30; // Maximum professors per university\n    uint256 public constant ENROLLMENT_FEE = 10 wei; // Fee for professor enrollment\n    uint256 public constant ELECTION_START_FEE = 100 wei; // Fee to start election\n    uint256 public constant ELECTION_DURATION_BLOCKS = 1000; // Election duration in blocks\n    uint256 public constant QUORUM_PERCENTAGE = 50; // Percentage needed for quorum (50%)\n\n    // ============ ENUMS ============\n    \n    enum Status { NO_ELECTION, IN_PROGRESS, CLOSED }\n\n    // ============ STATE VARIABLES ============\n    \n    // Current President (winner of last election)\n    address public currentPresident;\n    \n    // University and professor mappings\n    mapping(address => uint256) public universityProfessors;\n    mapping(address => bool) public isUniversity;\n    mapping(address => address) public professorToUniversity;\n    mapping(address => string) public universityNames;\n    \n    // Voting mappings\n    mapping(address => string) public votesMap;\n    mapping(address => bool) public hasVoted;\n    \n    // Election state\n    Status public VOTE_STATUS;\n    uint256 public votesNumber;\n    uint256 public electionEndBlock;\n    address public universityThatStartedElection; // University that started current election\n    address public feeHoldingAddress; // Address holding the election fee\n    uint256 public heldFee; // Amount of fee being held\n    string public WINNER;\n    \n    // University list\n    address[] public universities;\n    uint256 public univNumber;\n\n    // ============ EVENTS ============\n    \n    event PresidentChanged(address indexed previousPresident, address indexed newPresident);\n    event UniversityAdded(address indexed university, string name);\n    event UniversityRemoved(address indexed university, string name);\n    event UniversityVoted(address indexed university, string voteHash);\n    event ProfessorEnrolled(address indexed professor, address indexed university, uint256 totalProfessors, uint256 feePaid);\n    event ProfessorRemoved(address indexed professor, address indexed university, uint256 totalProfessors);\n    event StatusChanged(Status newStatus);\n    event ElectionStarted(address indexed university, uint256 electionEndBlock, uint256 feeHeld);\n    event ElectionClosed(string winner, uint256 totalVotes);\n    event FeeReceived(address indexed from, address indexed to, uint256 amount);\n    event FeeReturned(address indexed to, uint256 amount);\n\n    // ============ MODIFIERS ============\n    \n    modifier onlyCurrentPresident() {\n        require(msg.sender == currentPresident, \"Only current president can call this function\");\n        _;\n    }\n    \n    modifier onlyWhenNoElection() {\n        require(VOTE_STATUS == Status.NO_ELECTION, \"Action not allowed during election\");\n        _;\n    }\n\n    modifier onlyDuringElection() {\n        require(VOTE_STATUS == Status.IN_PROGRESS, \"Election is not in progress\");\n        require(block.number < electionEndBlock, \"Election has ended\");\n        _;\n    }\n\n    modifier onlyUniversities() {\n        require(isUniversity[msg.sender], \"Sender is not a recognized university\");\n        _;\n    }\n\n    modifier onlyWhenClosed() {\n        require(VOTE_STATUS == Status.CLOSED, \"Election is not closed\");\n        _;\n    }\n\n    modifier validAddress(address _address) {\n        require(_address != address(0), \"Invalid address: zero address\");\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(VOTE_STATUS != Status.IN_PROGRESS || !hasVoted[msg.sender], \"Reentrancy not allowed\");\n        _;\n    }\n\n    // ============ CONSTRUCTOR ============\n    \n    constructor() {\n        VOTE_STATUS = Status.NO_ELECTION;\n        votesNumber = 0;\n        univNumber = 0;\n        heldFee = 0;\n        currentPresident = msg.sender;\n        \n        emit PresidentChanged(address(0), currentPresident);\n    }\n\n    // ============ PRESIDENT MANAGEMENT FUNCTIONS ============\n    \n    /**\n     * @dev Add a new university to the system (only current president)\n     * @param university The address of the university\n     * @param name The name of the university\n     */\n    function addUniversity(address university, string memory name) \n        external \n        onlyCurrentPresident \n        onlyWhenNoElection \n        validAddress(university) \n    {\n        require(!isUniversity[university], \"University already exists\");\n        require(bytes(name).length > 0, \"University name cannot be empty\");\n        require(bytes(name).length <= 100, \"University name too long\");\n        require(university != currentPresident, \"President cannot be a university\");\n\n        universities.push(university);\n        isUniversity[university] = true;\n        universityNames[university] = name;\n        universityProfessors[university] = 0;\n        univNumber = universities.length;\n\n        emit UniversityAdded(university, name);\n    }\n\n    /**\n     * @dev Remove a university from the system (only current president)\n     * @param university The address of the university to remove\n     */\n    function removeUniversity(address university) \n        external \n        onlyCurrentPresident \n        onlyWhenNoElection \n        validAddress(university) \n    {\n        require(isUniversity[university], \"University does not exist\");\n        require(universityProfessors[university] == 0, \"Cannot remove university with enrolled professors\");\n\n        // Find and remove university from array\n        for (uint256 i = 0; i < universities.length; i++) {\n            if (universities[i] == university) {\n                universities[i] = universities[universities.length - 1];\n                universities.pop();\n                break;\n            }\n        }\n\n        string memory name = universityNames[university];\n        \n        // Clean up mappings\n        isUniversity[university] = false;\n        universityNames[university] = \"\";\n        hasVoted[university] = false;\n        votesMap[university] = \"\";\n        \n        univNumber = universities.length;\n\n        emit UniversityRemoved(university, name);\n    }\n\n    // ============ PROFESSOR MANAGEMENT FUNCTIONS ============\n    \n    /**\n     * @dev Enroll a professor in a university\n     * @param university The university address to enroll the professor in\n     */\n    function enrollProfessor(address university) \n        external \n        payable \n        onlyWhenNoElection \n        validAddress(university)\n        nonReentrant \n    {\n        require(isUniversity[university], \"Invalid university address\");\n        require(professorToUniversity[msg.sender] == address(0), \"Professor already enrolled\");\n        require(universityProfessors[university] < CAP, \"University at capacity\");\n        require(msg.value >= ENROLLMENT_FEE, \"Insufficient enrollment fee\");\n        require(msg.sender != university, \"University cannot enroll itself as professor\");\n\n        // Store the fee for potential refund calculation\n        uint256 feeToTransfer = ENROLLMENT_FEE;\n        uint256 refund = msg.value - ENROLLMENT_FEE;\n\n        // Assign professor to university\n        professorToUniversity[msg.sender] = university;\n        universityProfessors[university] += 1;\n\n        // Transfer fee to university\n        (bool success, ) = payable(university).call{value: feeToTransfer}(\"\");\n        require(success, \"Fee transfer to university failed\");\n\n        // Refund excess payment\n        if (refund > 0) {\n            (bool refundSuccess, ) = payable(msg.sender).call{value: refund}(\"\");\n            require(refundSuccess, \"Refund failed\");\n        }\n\n        emit FeeReceived(msg.sender, university, feeToTransfer);\n        emit ProfessorEnrolled(msg.sender, university, universityProfessors[university], feeToTransfer);\n    }\n\n    /**\n     * @dev Remove a professor from their current university\n     */\n    function removeProfessor() external onlyWhenNoElection nonReentrant {\n        address university = professorToUniversity[msg.sender];\n        require(university != address(0), \"Professor not enrolled in any university\");\n\n        // Update state before external call (CEI pattern)\n        universityProfessors[university] -= 1;\n        professorToUniversity[msg.sender] = address(0);\n\n        emit ProfessorRemoved(msg.sender, university, universityProfessors[university]);\n    }\n\n    // ============ ELECTION FUNCTIONS ============\n    \n    /**\n     * @dev Start a new election (can be called by any university with fee)\n     */\n    function startVotation() external payable onlyWhenNoElection onlyUniversities nonReentrant {\n        require(univNumber > 0, \"No universities registered\");\n        require(msg.value >= ELECTION_START_FEE, \"Insufficient election start fee\");\n        \n        // Store fee information\n        uint256 refund = msg.value - ELECTION_START_FEE;\n        heldFee = ELECTION_START_FEE;\n        feeHoldingAddress = address(this);\n        universityThatStartedElection = msg.sender;\n        \n        // Refund excess payment\n        if (refund > 0) {\n            (bool refundSuccess, ) = payable(msg.sender).call{value: refund}(\"\");\n            require(refundSuccess, \"Refund failed\");\n        }\n\n        // Set election state\n        VOTE_STATUS = Status.IN_PROGRESS;\n        electionEndBlock = block.number + ELECTION_DURATION_BLOCKS;\n        votesNumber = 0;\n\n        // Reset voting state for all universities\n        for (uint256 i = 0; i < universities.length; i++) {\n            hasVoted[universities[i]] = false;\n            votesMap[universities[i]] = \"\";\n        }\n\n        emit ElectionStarted(msg.sender, electionEndBlock, heldFee);\n        emit StatusChanged(VOTE_STATUS);\n    }\n\n    /**\n     * @dev Submit a vote during an active election\n     * @param voteData The encrypted vote data as a JSON string\n     */\n    function vote(string memory voteData) external onlyDuringElection onlyUniversities {\n        require(!hasVoted[msg.sender], \"University has already voted\");\n        require(bytes(voteData).length > 0, \"Vote data cannot be empty\");\n        require(bytes(voteData).length <= 1000, \"Vote data too large\");\n\n        // Mark university as voted and store vote\n        hasVoted[msg.sender] = true;\n        votesMap[msg.sender] = voteData;\n        votesNumber += 1;\n\n        emit UniversityVoted(msg.sender, voteData);\n\n        // Auto-check if election should close\n        _checkElectionStatus();\n    }\n\n    /**\n     * @dev Check if election should be closed and close it if conditions are met\n     */\n    function checkStatus() external {\n        _checkElectionStatus();\n    }\n\n    /**\n     * @dev Internal function to check and update election status\n     */\n    function _checkElectionStatus() internal {\n        if (VOTE_STATUS == Status.IN_PROGRESS) {\n            bool shouldClose = (votesNumber >= univNumber) || (block.number >= electionEndBlock);\n            \n            if (shouldClose) {\n                VOTE_STATUS = Status.CLOSED;\n                emit StatusChanged(VOTE_STATUS);\n            }\n        }\n    }\n\n    /**\n     * @dev Close the election and set the winner\n     * @param winningVote The winning vote result as a JSON string\n     */\n    function close(string memory winningVote) external onlyWhenClosed {\n        require(bytes(winningVote).length > 0, \"Winner data cannot be empty\");\n        require(bytes(winningVote).length <= 500, \"Winner data too large\");\n\n        // Store winner\n        WINNER = winningVote;\n        uint256 totalVotes = votesNumber;\n\n        // Return fee to university that started election\n        if (heldFee > 0 && universityThatStartedElection != address(0)) {\n            uint256 feeToReturn = heldFee;\n            address recipient = universityThatStartedElection;\n            \n            // Reset fee tracking\n            heldFee = 0;\n            feeHoldingAddress = address(0);\n            \n            // Transfer fee back\n            (bool success, ) = payable(recipient).call{value: feeToReturn}(\"\");\n            if (success) {\n                emit FeeReturned(recipient, feeToReturn);\n            }\n        }\n\n        // Set new president based on election winner\n        // In a real implementation, you'd parse winningVote to determine the new president\n        // For simplicity, we'll set the university that started the election as the new president\n        // You can modify this logic based on your specific requirements\n        address newPresident = universityThatStartedElection;\n        address oldPresident = currentPresident;\n        currentPresident = newPresident;\n\n        // Reset election state\n        VOTE_STATUS = Status.NO_ELECTION;\n        votesNumber = 0;\n        electionEndBlock = 0;\n        universityThatStartedElection = address(0);\n\n        // Clear voting data\n        for (uint256 i = 0; i < universities.length; i++) {\n            hasVoted[universities[i]] = false;\n            votesMap[universities[i]] = \"\";\n        }\n\n        emit ElectionClosed(winningVote, totalVotes);\n        emit PresidentChanged(oldPresident, newPresident);\n        emit StatusChanged(VOTE_STATUS);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n    \n    /**\n     * @dev Get all university addresses\n     * @return Array of university addresses\n     */\n    function getAllUniversities() external view returns (address[] memory) {\n        return universities;\n    }\n\n    /**\n     * @dev Get all university addresses with their names\n     * @return addresses Array of university addresses\n     * @return names Array of university names\n     */\n    function getAllUniversitiesWithNames() external view returns (address[] memory addresses, string[] memory names) {\n        addresses = new address[](universities.length);\n        names = new string[](universities.length);\n        \n        for (uint256 i = 0; i < universities.length; i++) {\n            addresses[i] = universities[i];\n            names[i] = universityNames[universities[i]];\n        }\n        \n        return (addresses, names);\n    }\n\n    /**\n     * @dev Get election information\n     * @return status Current election status\n     * @return endBlock Block number when election ends\n     * @return totalVotes Number of votes cast\n     * @return totalUniversities Total number of universities\n     */\n    function getElectionInfo() external view returns (\n        Status status,\n        uint256 endBlock,\n        uint256 totalVotes,\n        uint256 totalUniversities\n    ) {\n        return (VOTE_STATUS, electionEndBlock, votesNumber, univNumber);\n    }\n\n    /**\n     * @dev Get university information\n     * @param university The university address\n     * @return isValid Whether the address is a valid university\n     * @return name The name of the university\n     * @return professorCount Number of professors in the university\n     * @return voted Whether the university has voted in current election\n     */\n    function getUniversityInfo(address university) external view returns (\n        bool isValid,\n        string memory name,\n        uint256 professorCount,\n        bool voted\n    ) {\n        return (\n            isUniversity[university], \n            universityNames[university], \n            universityProfessors[university], \n            hasVoted[university]\n        );\n    }\n\n    /**\n     * @dev Check if an address is a professor and get their university\n     * @param professor The professor address to check\n     * @return university The university the professor is enrolled in (address(0) if not enrolled)\n     */\n    function getProfessorInfo(address professor) external view returns (address university) {\n        return professorToUniversity[professor];\n    }\n\n    /**\n     * @dev Get current block number (useful for frontend)\n     * @return Current block number\n     */\n    function getCurrentBlock() external view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @dev Get contract balance\n     * @return Current contract balance in wei\n     */\n    function getContractBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev Check if an address is the current president\n     * @param account The address to check\n     * @return True if the address is the current president\n     */\n    function isCurrentPresident(address account) external view returns (bool) {\n        return account == currentPresident;\n    }\n\n    /**\n     * @dev Get held fee information\n     * @return amount Amount of fee being held\n     * @return holder Address holding the fee\n     * @return starter University that started the election\n     */\n    function getHeldFeeInfo() external view returns (uint256 amount, address holder, address starter) {\n        return (heldFee, feeHoldingAddress, universityThatStartedElection);\n    }\n\n    // ============ FALLBACK FUNCTIONS ============\n    \n    /**\n     * @dev Fallback function to reject direct payments\n     */\n    receive() external payable {\n        revert(\"Direct payments not accepted. Use specific functions.\");\n    }\n\n    /**\n     * @dev Fallback function for calls to non-existent functions\n     */\n    fallback() external payable {\n        revert(\"Function does not exist\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}